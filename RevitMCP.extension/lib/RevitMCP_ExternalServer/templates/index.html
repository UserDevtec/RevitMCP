<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RevitMCP Chat</title>
    <script defer src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div id="app-container">
        <div id="sidebar">
            <h2>Chat History</h2>
            <ul id="chat-history-list">
                <!-- Chat history items will be populated here by JavaScript -->
            </ul>
            <div class="sidebar-actions">
                <button id="settings-button">&#8942;</button> <!-- Settings Icon changed to vertical ellipsis -->
            </div>
        </div>
        <div id="chat-area">
            <div id="top-bar">
                <button id="top-bar-toggle-sidebar" title="Toggle Sidebar">&#9776;</button> <!-- New sidebar toggle -->
                <button id="top-bar-new-chat" title="New Chat">+</button> <!-- New new chat button -->
                <div id="controls">
                    <label for="model-selector">Model:</label>
                    <select id="model-selector">
                        <option value="echo_model">Echo Model (Test)</option>
                        <optgroup label="OpenAI">
                            <option value="gpt-5.2">GPT-5.2</option>
                            <option value="gpt-5-mini">GPT-5 mini</option>
                        </optgroup>
                        <optgroup label="Anthropic">
                            <option value="claude-sonnet-4-6">claude-sonnet-4-6</option>
                            <option value="claude-opus-4-6">claude-opus-4-6</option>
                            <option value="claude-haiku-4-5">claude-haiku-4-5</option>
                        </optgroup>
                        <optgroup label="Google Gemini">
                            <option value="gemini-3-pro-preview-02-05">Gemini 3 Pro (Preview)</option>
                            <option value="gemini-3-flash-preview-02-05">Gemini 3 Flash (Preview)</option>
                        </optgroup>
                    </select>
                    <!-- API Key input removed from here -->
                </div>
            </div>
            <div id="message-log">
                <!-- Messages will be appended here -->
            </div>
            <div id="input-area">
                <input type="text" id="message-input" placeholder="Ask anything">
                <button id="send-button">Send</button>
            </div>
            <div id="status">Ready</div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeSettingsModal()">&times;</span>
            <h2>Settings</h2>
            
            <label for="openai-api-key">OpenAI API Key:</label>
            <input type="password" id="openai-api-key" name="openai-api-key">

            <label for="anthropic-api-key">Anthropic API Key:</label>
            <input type="password" id="anthropic-api-key" name="anthropic-api-key">

            <label for="google-api-key">Google API Key:</label>
            <input type="password" id="google-api-key" name="google-api-key">

            <label for="preferred-model">Preferred Model:</label>
            <select id="preferred-model" name="preferred-model">
                <!-- Options will be populated by JavaScript -->
            </select>
            <button onclick="saveSettings()">Save Settings</button>
            <p id="settings-status"></p>
        </div>
    </div>

    <script>
        const messageLog = document.getElementById('message-log');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const modelSelector = document.getElementById('model-selector');
        const statusDiv = document.getElementById('status');
        const chatHistoryList = document.getElementById('chat-history-list');
        const newChatButton = document.getElementById('new-chat-button');

        // Settings Modal elements
        const settingsButton = document.getElementById('settings-button');
        const settingsModal = document.getElementById('settings-modal');
        const closeSettingsModalButton = settingsModal.querySelector('.close-button');
        const openaiApiKeyInput = document.getElementById('openai-api-key');
        const anthropicApiKeyInput = document.getElementById('anthropic-api-key');
        const googleApiKeyInput = document.getElementById('google-api-key');
        const preferredModelSelect = document.getElementById('preferred-model');
        const settingsStatus = document.getElementById('settings-status');

        // New top bar buttons
        const topBarToggleSidebarButton = document.getElementById('top-bar-toggle-sidebar');
        const topBarNewChatButton = document.getElementById('top-bar-new-chat');

        let currentConversation = [];
        let allChats = {};
        let activeChatId = null;

        // Wrap dependent initializations in DOMContentLoaded
        document.addEventListener('DOMContentLoaded', () => {
            // Initial load of chats from storage
            loadChatsFromStorage();
            loadApiKeysFromStorage(); // Load API keys on start

            // Sidebar Toggle Functionality
            const sidebar = document.getElementById('sidebar');

            // Load sidebar state from localStorage
            // Default to open (not closed), so isSidebarClosed is true if item is 'true'
            let isSidebarClosed = localStorage.getItem('revitMCP_sidebar_closed') === 'true'; 
            
            function applySidebarState() {
                if (isSidebarClosed) {
                    sidebar.classList.add('sidebar-closed');
                    topBarToggleSidebarButton.textContent = '>>'; // Sidebar closed
                } else {
                    sidebar.classList.remove('sidebar-closed');
                    topBarToggleSidebarButton.textContent = '<<'; // Sidebar open
                }
            }
            // Initialize sidebar state: if nothing in localStorage, sidebar should be open (not closed).
            // So, if 'revitMCP_sidebar_closed' is null, isSidebarClosed is false.
            if (localStorage.getItem('revitMCP_sidebar_closed') === null) {
                isSidebarClosed = false; // Default to open
            }
            applySidebarState(); // Apply initial state

            topBarToggleSidebarButton.addEventListener('click', () => {
                isSidebarClosed = !isSidebarClosed; 
                applySidebarState(); 
                localStorage.setItem('revitMCP_sidebar_closed', isSidebarClosed);
            });
            
            // Connect new top-bar new chat button
            topBarNewChatButton.addEventListener('click', startNewChat);

            // Load last selected model
            const savedModel = localStorage.getItem('revitMCPselectedModel');
            if (savedModel) {
                modelSelector.value = savedModel;
            }
        });

        // --- Settings Modal Logic --- (listeners can be set up outside DOMContentLoaded)
        function openSettingsModal() {
            // Load current settings into the modal inputs
            openaiApiKeyInput.value = localStorage.getItem('revitMCP_openai_api_key') || '';
            anthropicApiKeyInput.value = localStorage.getItem('revitMCP_anthropic_api_key') || '';
            googleApiKeyInput.value = localStorage.getItem('revitMCP_google_api_key') || '';
            
            // Populate the preferred model selector by copying options from the main model selector
            preferredModelSelect.innerHTML = modelSelector.innerHTML;
            // Set the selected value for the preferred model
            const savedPreferredModel = localStorage.getItem('revitMCPselectedModel');
            if (savedPreferredModel) {
                preferredModelSelect.value = savedPreferredModel;
            } else if (modelSelector.options.length > 0) {
                preferredModelSelect.value = modelSelector.options[0].value; // Default to first option of main selector
            }

            settingsModal.style.display = 'block';
            settingsStatus.textContent = '';
        }

        function closeSettingsModal() {
            settingsModal.style.display = 'none';
        }

        function saveSettings() {
            localStorage.setItem('revitMCP_openai_api_key', openaiApiKeyInput.value.trim());
            localStorage.setItem('revitMCP_anthropic_api_key', anthropicApiKeyInput.value.trim());
            localStorage.setItem('revitMCP_google_api_key', googleApiKeyInput.value.trim());
            localStorage.setItem('revitMCPselectedModel', preferredModelSelect.value);
            
            settingsStatus.textContent = 'Settings saved!';
            // Update the main model selector as well if the preferred model changed
            // populateModelSelector(modelSelector, true); // No longer needed, main selector is static
            modelSelector.value = preferredModelSelect.value;
            
            setTimeout(() => {
                closeSettingsModal();
            }, 1000);
        }

        // Attach event listeners for settings modal
        if (settingsButton) {
            settingsButton.addEventListener('click', openSettingsModal);
        }
        if (closeSettingsModalButton) {
            closeSettingsModalButton.addEventListener('click', closeSettingsModal);
        }
        // saveSettings is called by button onclick directly in HTML

        // --- Chat History Management --- (functions defined, called by DOMContentLoaded or events)
        function generateChatId() {
            return 'chat_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function saveCurrentChat() {
            if (activeChatId && currentConversation.length > 0) {
                allChats[activeChatId] = [...currentConversation];
                localStorage.setItem('allRevitMCPChats', JSON.stringify(allChats));
                renderChatHistoryList();
            }
        }
        
        function getChatTitle(conversationOrChatObject) {
            // Check if it's the full chat object which might have metadata.customTitle
            if (conversationOrChatObject && typeof conversationOrChatObject === 'object' && !Array.isArray(conversationOrChatObject)) {
                if (conversationOrChatObject.metadata && conversationOrChatObject.metadata.customTitle) {
                    return conversationOrChatObject.metadata.customTitle;
                }
                // If no customTitle, fall back to deriving from messages (assuming it has a messages array)
                // This part needs care: what if conversationOrChatObject is the array directly?
                // Let's assume the argument to getChatTitle is always the array of messages from allChats[chatId]
                // OR the chat object from allChats[chatId] which would be an array of messages (current structure)
                // OR the chat object which is an object containing messages and metadata (new structure)

                // To handle both current (array) and potential future (object with .messages):
                let messages = Array.isArray(conversationOrChatObject) ? conversationOrChatObject : conversationOrChatObject.messages;
                if (!messages) messages = []; // Fallback if structure is unexpected

                const firstUserMessage = messages.find(msg => msg.role === 'user');
                if (firstUserMessage && firstUserMessage.content) {
                    return firstUserMessage.content.substring(0, 30) + (firstUserMessage.content.length > 30 ? '...' : '');
                }
                return "New Chat"; // Default if no user message or empty
            }
            // Fallback for old calls or direct message array
            if (Array.isArray(conversationOrChatObject) && conversationOrChatObject.length === 0) return "New Chat";
            if (Array.isArray(conversationOrChatObject)) {
                const firstUserMessage = conversationOrChatObject.find(msg => msg.role === 'user');
                 if (firstUserMessage && firstUserMessage.content) {
                    return firstUserMessage.content.substring(0, 30) + (firstUserMessage.content.length > 30 ? '...' : '');
                }
            }
            
            // Fallback for empty/newly created chats before any messages if not handled above
            const chatKey = Object.keys(allChats).find(key => allChats[key] === conversationOrChatObject);
            const chatIndex = chatKey ? Object.keys(allChats).indexOf(chatKey) : -1;
            return "Chat " + (chatIndex >= 0 ? chatIndex + 1 : Object.keys(allChats).length +1) ;
        }

        function renderChatHistoryList() {
            chatHistoryList.innerHTML = '';
            const sortedChatIds = Object.keys(allChats).sort((a,b) => {
                 return parseInt(b.split('_')[1]) - parseInt(a.split('_')[1]);
            });

            sortedChatIds.forEach(chatId => {
                const chat = allChats[chatId];
                const listItem = document.createElement('li');
                
                const container = document.createElement('div');
                container.classList.add('chat-item-container');

                const titleSpan = document.createElement('span');
                titleSpan.classList.add('chat-item-title');
                titleSpan.textContent = getChatTitle(chat); // Use existing function for now
                titleSpan.title = getChatTitle(chat); // Full title on hover

                const optionsButton = document.createElement('button');
                optionsButton.classList.add('chat-item-options-button');
                optionsButton.innerHTML = '&#8942;'; // Vertical ellipsis HTML entity
                optionsButton.title = 'More options';
                optionsButton.addEventListener('click', (event) => {
                    event.stopPropagation(); // Prevent li click event
                    toggleChatOptionsMenu(event.currentTarget, chatId);
                });

                container.appendChild(titleSpan);
                container.appendChild(optionsButton);
                listItem.appendChild(container);

                listItem.dataset.chatId = chatId;
                if (chatId === activeChatId) {
                    listItem.classList.add('active-chat');
                }
                listItem.addEventListener('click', () => loadChat(chatId));
                chatHistoryList.appendChild(listItem);
            });
        }

        function toggleChatOptionsMenu(buttonElement, chatId) {
            closeAllOptionMenus(); // Close any other open menus
            let menu = document.getElementById('chat-options-menu-' + chatId);
            if (!menu) {
                menu = createChatOptionsMenu(chatId);
                // Position menu near the button
                const rect = buttonElement.getBoundingClientRect();
                document.body.appendChild(menu); // Append to body to avoid overflow issues
                menu.style.top = (rect.bottom + window.scrollY) + 'px';
                menu.style.left = (rect.left + window.scrollX - menu.offsetWidth + rect.width) + 'px';
            }
            menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
        }

        function createChatOptionsMenu(chatId) {
            const menu = document.createElement('div');
            menu.id = 'chat-options-menu-' + chatId;
            menu.classList.add('chat-options-menu');

            const renameButton = document.createElement('button');
            renameButton.textContent = 'Rename';
            renameButton.addEventListener('click', () => {
                renameChat(chatId);
                menu.style.display = 'none';
            });

            const deleteButton = document.createElement('button');
            deleteButton.textContent = 'Delete';
            deleteButton.addEventListener('click', () => {
                deleteChat(chatId);
                menu.style.display = 'none';
            });

            menu.appendChild(renameButton);
            menu.appendChild(deleteButton);
            return menu;
        }

        function closeAllOptionMenus() {
            document.querySelectorAll('.chat-options-menu').forEach(menu => {
                menu.style.display = 'none';
            });
        }
        
        // Add a global click listener to close menus if clicked outside
        document.addEventListener('click', function(event) {
            const openMenus = document.querySelectorAll('.chat-options-menu');
            let clickedInsideMenu = false;
            openMenus.forEach(menu => {
                if (menu.contains(event.target)) {
                    clickedInsideMenu = true;
                }
            });
            const clickedOnOptionsButton = event.target.closest('.chat-item-options-button');

            if (!clickedInsideMenu && !clickedOnOptionsButton) {
                closeAllOptionMenus();
            }
        });

        function loadChat(chatId) {
            if (allChats[chatId]) {
                saveCurrentChat();
                activeChatId = chatId;
                currentConversation = [...allChats[chatId]];
                messageLog.innerHTML = '';
                currentConversation.forEach(msg => displayMessage(msg.role, msg.content, false));
                renderChatHistoryList();
                statusDiv.textContent = `Loaded chat: ${getChatTitle(currentConversation)}`;
            }
        }

        function startNewChat() {
            saveCurrentChat();
            activeChatId = generateChatId();
            currentConversation = [];
            messageLog.innerHTML = '';
            allChats[activeChatId] = [];
            renderChatHistoryList();
            statusDiv.textContent = 'New chat started.';
            messageInput.focus();
        }
        
        function loadChatsFromStorage() {
            const storedChats = localStorage.getItem('allRevitMCPChats');
            if (storedChats) {
                allChats = JSON.parse(storedChats);
                const chatIds = Object.keys(allChats);
                if (chatIds.length > 0) {
                    const mostRecentChatId = chatIds.sort((a,b) => parseInt(b.split('_')[1]) - parseInt(a.split('_')[1]))[0];
                    loadChat(mostRecentChatId || chatIds[0]);
                } else {
                    startNewChat();
                }
            } else {
                startNewChat();
            }
            renderChatHistoryList(); // This is fine here, as DOM elements exist by the time it's called
        }

        function loadApiKeysFromStorage() {
            // Implementation of loadApiKeysFromStorage function
        }

        // --- Message Display & Sending --- (functions defined, called by events)
        function displayMessage(role, message, shouldSave = true) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', role === 'user' ? 'user-message' : 'bot-message');
            
            if (role === 'bot') {
                if (typeof marked !== 'undefined' && marked && typeof marked.parse === 'function') {
                    messageDiv.innerHTML = marked.parse(message || " ");
                } else {
                    console.warn("'marked' library is not available. Displaying raw message. Check CDN link or network.");
                    messageDiv.textContent = message; // Fallback to raw text
                }
            } else {
                messageDiv.textContent = message;
            }
            
            messageLog.appendChild(messageDiv);
            messageLog.scrollTop = messageLog.scrollHeight;

            if (shouldSave) {
                currentConversation.push({ role: role, content: message });
                saveCurrentChat();
            }
        }

        async function sendMessage() {
            const messageText = messageInput.value.trim();
            if (!messageText) return;

            displayMessage('user', messageText);
            
            const selectedModelValue = modelSelector.value;
            let apiKeyToUse = getApiKeyForModel(selectedModelValue); // Use existing helper

            // No longer need special parsing for /get_view, LLM handles it.
            
            const payload = {
                conversation: [...currentConversation], // currentConversation includes the new user message from displayMessage
                model: selectedModelValue,
                apiKey: apiKeyToUse // This will be the specific key for the selected model's provider
            };
            
            messageInput.value = '';
            statusDiv.textContent = 'Sending...';

            try {
                const response = await fetch('/chat_api', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                }

                const data = await response.json();

                // Display the main text reply from the LLM
                if (data.reply) {
                    displayMessage('bot', data.reply);
                }

                // Check if there's an image to display alongside the text reply
                if (data.image_output && data.image_output.status === 'success') {
                    displayImageOutput(data.image_output.image_data, data.image_output.content_type);
                } else if (data.image_output && data.image_output.status === 'error') {
                    // Optionally display a specific error if the image tool failed but LLM still replied
                    console.warn("Image tool failed:", data.image_output.message);
                    // You could display a small error message here too if desired, e.g.:
                    // displayMessage('bot', `(Note: Could not retrieve image - ${data.image_output.message})`, false);
                }

                // Handle other tool_output or tool_error types if they are sent outside of image_output
                // (This part might be less relevant if all tool interactions are now summarized by the LLM in data.reply)
                if (data.reply_type === 'tool_output' && (!data.image_output || data.image_output.tool_name !== 'get_revit_view')) {
                    displayToolOutput(data.data, data.tool_name || 'Tool'); 
                } else if (data.reply_type === 'tool_error') {
                    // This might be redundant if LLM incorporates tool errors into its main reply
                    displayMessage('bot', `Tool Error (${data.tool_name || 'Unknown Tool'}): ${data.error || 'Unknown error'}`);
                }

                statusDiv.textContent = 'Ready';

            } catch (error) {
                console.error('Error sending message:', error);
                displayMessage('bot', `Error: ${error.message}`);
                statusDiv.textContent = `Error: ${error.message.substring(0,100)}`;
            }
        }

        function displayImageOutput(imageData, contentType) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', 'bot-message', 'image-output-message');

            const img = document.createElement('img');
            img.src = `data:${contentType};base64,${imageData}`;
            img.alt = "Revit View Export";
            img.style.maxWidth = '100%';
            img.style.maxHeight = '500px'; // Limit image height
            img.style.borderRadius = '8px';

            messageDiv.appendChild(img);
            messageLog.appendChild(messageDiv);
            messageLog.scrollTop = messageLog.scrollHeight;

            // Optionally save a placeholder or info about the image to conversation history
            // currentConversation.push({ role: 'assistant', type: 'image_response', tool_name: 'get_revit_view', content: `Displayed image: ${contentType}` });
            // saveCurrentChat();
        }

        function displayToolOutput(toolData, toolName) { // Modified to accept toolName
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', 'bot-message', 'tool-output-message');
            messageDiv.textContent = `Tool Output (${toolName || 'Tool'}): ${toolData || 'No output'}`;
            messageLog.appendChild(messageDiv);
            messageLog.scrollTop = messageLog.scrollHeight;
        }

        // Event listeners for UI elements (can be set up outside DOMContentLoaded as elements exist)
        sendButton.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
        // newChatButton.addEventListener('click', startNewChat); // Old button listener removed
        
        // Event listener for model selector (can be outside DOMContentLoaded)
        modelSelector.addEventListener('change', () => {
            localStorage.setItem('revitMCPselectedModel', modelSelector.value);
        });

        function renameChat(chatId) {
            const chatToRename = allChats[chatId];
            if (!chatToRename) return;

            const currentTitle = getChatTitle(chatToRename);
            const newTitle = prompt("Enter new name for chat:", currentTitle);

            if (newTitle && newTitle.trim() !== '' && newTitle !== currentTitle) {
                // If we want to store custom titles, we need to modify the chat object structure.
                // For now, let's assume getChatTitle is sufficient or we add a 'customTitle' field.
                if (!allChats[chatId].metadata) {
                    allChats[chatId].metadata = {};
                }
                allChats[chatId].metadata.customTitle = newTitle.trim();
                
                // Update localStorage immediately
                localStorage.setItem('allRevitMCPChats', JSON.stringify(allChats));
                renderChatHistoryList(); // Re-render to show new title
                if (chatId === activeChatId) {
                    statusDiv.textContent = `Chat renamed to: ${newTitle.trim()}`;
                }
            }
        }

        function deleteChat(chatId) {
            const chatToDelete = allChats[chatId];
            if (!chatToDelete) return;

            const chatTitle = getChatTitle(chatToDelete);
            if (confirm("Are you sure you want to delete chat: '" + chatTitle + "'?")) {
                delete allChats[chatId];
                localStorage.setItem('allRevitMCPChats', JSON.stringify(allChats));
                
                if (activeChatId === chatId) {
                    activeChatId = null; // Clear active chat
                    // Find the most recent remaining chat to load, or start new if none left
                    const remainingChatIds = Object.keys(allChats).sort((a,b) => parseInt(b.split('_')[1]) - parseInt(a.split('_')[1]));
                    if (remainingChatIds.length > 0) {
                        loadChat(remainingChatIds[0]);
                    } else {
                        startNewChat();
                    }
                } else {
                    renderChatHistoryList(); // Just re-render if a non-active chat was deleted
                }
                statusDiv.textContent = `Chat '${chatTitle}' deleted.`;
            }
        }

        function getApiKeyForModel(modelName) {
            if (!modelName) return ''; // Should not happen if a model is always selected

            if (modelName.startsWith('gpt-') || /^o\d/.test(modelName)) {
                return localStorage.getItem('revitMCP_openai_api_key') || '';
            } else if (modelName.startsWith('claude-')) {
                return localStorage.getItem('revitMCP_anthropic_api_key') || '';
            } else if (modelName.startsWith('gemini-')) {
                return localStorage.getItem('revitMCP_google_api_key') || '';
            }
            // For 'echo_model' or any other model not matching known prefixes, no API key is needed by the backend.
            return ''; 
        }

    </script>
</body>
</html>
